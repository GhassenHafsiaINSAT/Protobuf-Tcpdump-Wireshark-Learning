
// Check for HTTP/2 connection preface
        const unsigned char *http2_header = packet + ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length;
        int remaining_len = length - (ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length);

        // Handle HTTP/2 connection preface
        if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
            http2_header += 24; // Skip connection preface
            remaining_len -= 24;
        }

        // Loop through the HTTP/2 frames
        while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
            uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
            uint8_t frame_type = http2_header[3];

            // Check for DATA frame (type 0x0)
            if (frame_type == 0x0) {
                if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                    // Check for gRPC content type in the payload
                    if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                        memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                        print_packet_info(ip, tcp, timestamp);
                    }
                }
            }

            http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
            remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
        }
    }
}



0000   00 00 00 00 00 00 00 00 00 00 00 00 86 dd 60 06
0010   78 b8 01 40 06 40 00 00 00 00 00 00 00 00 00 00
0020   00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00
0030   00 00 00 00 00 01 97 24 c3 83 8e 13 ef 61 3f f8
0040   ef 5e 80 18 02 00 01 48 00 00 01 01 08 0a 1f 52
0050   99 69 1f 52 99 68 00 00 00 04 01 00 00 00 00 00
0060   00 d8 01 04 00 00 00 01 40 05 3a 70 61 74 68 1b
0070   2f 65 78 61 6d 70 6c 65 2e 43 68 65 63 6b 49 6e
0080   2f 47 65 74 46 65 61 74 75 72 65 40 0a 3a 61 75
0090   74 68 6f 72 69 74 79 0f 6c 6f 63 61 6c 68 6f 73
00a0   74 3a 35 30 30 35 31 83 86 40 0c 63 6f 6e 74 65
00b0   6e 74 2d 74 79 70 65 10 61 70 70 6c 69 63 61 74
00c0   69 6f 6e 2f 67 72 70 63 40 02 74 65 08 74 72 61
00d0   69 6c 65 72 73 40 14 67 72 70 63 2d 61 63 63 65
00e0   70 74 2d 65 6e 63 6f 64 69 6e 67 17 69 64 65 6e
00f0   74 69 74 79 2c 20 64 65 66 6c 61 74 65 2c 20 67
0100   7a 69 70 40 0a 75 73 65 72 2d 61 67 65 6e 74 30
0110   67 72 70 63 2d 70 79 74 68 6f 6e 2f 31 2e 36 35
0120   2e 34 20 67 72 70 63 2d 63 2f 34 32 2e 30 2e 30
0130   20 28 6c 69 6e 75 78 3b 20 63 68 74 74 70 32 29
0140   00 00 04 08 00 00 00 00 01 00 00 00 05 00 00 13
0150   00 01 00 00 00 01 00 00 00 00 0e 08 01 12 0a 54
0160   65 73 74 20 50 6f 69 6e 74 00 00 04 08 00 00 00
0170   00 00 00 00 00 05

0000   00 00 00 00 00 00 00 00 00 00 00 00 86 dd 60 06   ..............`.
0010   78 b8 01 40 06 40 00 00 00 00 00 00 00 00 00 00   x..@.@..........
0020   00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00   ................
0030   00 00 00 00 00 01 97 24 c3 83 8e 13 ef 61 3f f8   .......$.....a?.
0040   ef 5e 80 18 02 00 01 48 00 00 01 01 08 0a 1f 52   .^.....H.......R
0050   99 69 1f 52 99 68 00 00 00 04 01 00 00 00 00 00   .i.R.h..........
0060   00 d8 01 04 00 00 00 01 40 05 3a 70 61 74 68 1b   ........@.:path.
0070   2f 65 78 61 6d 70 6c 65 2e 43 68 65 63 6b 49 6e   /example.CheckIn
0080   2f 47 65 74 46 65 61 74 75 72 65 40 0a 3a 61 75   /GetFeature@.:au
0090   74 68 6f 72 69 74 79 0f 6c 6f 63 61 6c 68 6f 73   thority.localhos
00a0   74 3a 35 30 30 35 31 83 86 40 0c 63 6f 6e 74 65   t:50051..@.conte
00b0   6e 74 2d 74 79 70 65 10 61 70 70 6c 69 63 61 74   nt-type.applicat
00c0   69 6f 6e 2f 67 72 70 63 40 02 74 65 08 74 72 61   ion/grpc@.te.tra
00d0   69 6c 65 72 73 40 14 67 72 70 63 2d 61 63 63 65   ilers@.grpc-acce
00e0   70 74 2d 65 6e 63 6f 64 69 6e 67 17 69 64 65 6e   pt-encoding.iden
00f0   74 69 74 79 2c 20 64 65 66 6c 61 74 65 2c 20 67   tity, deflate, g
0100   7a 69 70 40 0a 75 73 65 72 2d 61 67 65 6e 74 30   zip@.user-agent0
0110   67 72 70 63 2d 70 79 74 68 6f 6e 2f 31 2e 36 35   grpc-python/1.65
0120   2e 34 20 67 72 70 63 2d 63 2f 34 32 2e 30 2e 30   .4 grpc-c/42.0.0
0130   20 28 6c 69 6e 75 78 3b 20 63 68 74 74 70 32 29    (linux; chttp2)
0140   00 00 04 08 00 00 00 00 01 00 00 00 05 00 00 13   ................
0150   00 01 00 00 00 01 00 00 00 00 0e 08 01 12 0a 54   ...............T
0160   65 73 74 20 50 6f 69 6e 74 00 00 04 08 00 00 00   est Point.......
0170   00 00 00 00 00 05                                 ......




if (ntohs(tcp->th_sport) != grpc_port || ntohs(tcp->th_dport) == grpc_port) {
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        char timestamp[100];
        strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&ts.tv_sec));
        sprintf(timestamp + strlen(timestamp), ".%06ld", ts.tv_nsec / 1000); // Append microseconds

        print_packet_info(ip, tcp, timestamp);

        // Check for HTTP/2 connection preface
        const unsigned char *http2_header = packet + ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length;
        int remaining_len = length - (ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length);

        // Handle HTTP/2 connection preface
        if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
            http2_header += 24; // Skip connection preface
            remaining_len -= 24;
        }

        // Loop through the HTTP/2 frames
        while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
            uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
            uint8_t frame_type = http2_header[3];

            // Check for DATA frame (type 0x0)
            if (frame_type == 0x0) {
                if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                    // Check for gRPC content type in the payload
                    if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                        memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                        print_packet_info(ip, tcp, timestamp);
                    }
                }
            }

            http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
            remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
        }
    }






    test 
    if (ntohs(tcp->source) == 50051 || ntohs(tcp->dest) == 50051) {
            struct timespec ts;
            clock_gettime(CLOCK_REALTIME, &ts);
            char timestamp[100];
            strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&ts.tv_sec));
            sprintf(timestamp + strlen(timestamp), ".%06ld", ts.tv_nsec / 1000); 
            


            // Check for HTTP/2 connection preface
            const unsigned char *http2_header = packet + 14 + ip_header_length + tcp_header_length;
            int remaining_len = length - (14 + ip_header_length + tcp_header_length);

            if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
                http2_header += 24; // Skip connection preface
                remaining_len -= 24;
            }

            // Loop through the HTTP/2 frames
            while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
                uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
                uint8_t frame_type = http2_header[3];

                // Check for DATA frame (type 0x0)
                if (frame_type == 0x0) {
                    if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                        // Check for gRPC content type in the payload
                        if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                            memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                            //print_packet_info(ip, tcp, timestamp);
                        }
                    }
                }

                http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
                remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
            }
        }