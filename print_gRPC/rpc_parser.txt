
// Check for HTTP/2 connection preface
        const unsigned char *http2_header = packet + ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length;
        int remaining_len = length - (ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length);

        // Handle HTTP/2 connection preface
        if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
            http2_header += 24; // Skip connection preface
            remaining_len -= 24;
        }

        // Loop through the HTTP/2 frames
        while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
            uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
            uint8_t frame_type = http2_header[3];

            // Check for DATA frame (type 0x0)
            if (frame_type == 0x0) {
                if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                    // Check for gRPC content type in the payload
                    if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                        memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                        print_packet_info(ip, tcp, timestamp);
                    }
                }
            }

            http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
            remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
        }
    }
}




if (ntohs(tcp->th_sport) != grpc_port || ntohs(tcp->th_dport) == grpc_port) {
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        char timestamp[100];
        strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&ts.tv_sec));
        sprintf(timestamp + strlen(timestamp), ".%06ld", ts.tv_nsec / 1000); // Append microseconds

        print_packet_info(ip, tcp, timestamp);

        // Check for HTTP/2 connection preface
        const unsigned char *http2_header = packet + ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length;
        int remaining_len = length - (ETHERNET_HEADER_LEN + ip_header_length + tcp_header_length);

        // Handle HTTP/2 connection preface
        if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
            http2_header += 24; // Skip connection preface
            remaining_len -= 24;
        }

        // Loop through the HTTP/2 frames
        while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
            uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
            uint8_t frame_type = http2_header[3];

            // Check for DATA frame (type 0x0)
            if (frame_type == 0x0) {
                if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                    // Check for gRPC content type in the payload
                    if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                        memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                        print_packet_info(ip, tcp, timestamp);
                    }
                }
            }

            http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
            remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
        }
    }






    test 
    if (ntohs(tcp->source) == 50051 || ntohs(tcp->dest) == 50051) {
            struct timespec ts;
            clock_gettime(CLOCK_REALTIME, &ts);
            char timestamp[100];
            strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&ts.tv_sec));
            sprintf(timestamp + strlen(timestamp), ".%06ld", ts.tv_nsec / 1000); 
            


            // Check for HTTP/2 connection preface
            const unsigned char *http2_header = packet + 14 + ip_header_length + tcp_header_length;
            int remaining_len = length - (14 + ip_header_length + tcp_header_length);

            if (remaining_len >= 24 && memcmp(http2_header, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n", 24) == 0) {
                http2_header += 24; // Skip connection preface
                remaining_len -= 24;
            }

            // Loop through the HTTP/2 frames
            while (remaining_len >= HTTP2_FRAME_HEADER_LEN) {
                uint32_t frame_length = (http2_header[0] << 16) | (http2_header[1] << 8) | http2_header[2];
                uint8_t frame_type = http2_header[3];

                // Check for DATA frame (type 0x0)
                if (frame_type == 0x0) {
                    if (remaining_len >= (HTTP2_FRAME_HEADER_LEN + frame_length)) {
                        // Check for gRPC content type in the payload
                        if (frame_length >= GRPC_CONTENT_TYPE_LEN &&
                            memcmp(http2_header + HTTP2_FRAME_HEADER_LEN, GRPC_CONTENT_TYPE, GRPC_CONTENT_TYPE_LEN) == 0) {
                            //print_packet_info(ip, tcp, timestamp);
                        }
                    }
                }

                http2_header += HTTP2_FRAME_HEADER_LEN + frame_length;
                remaining_len -= HTTP2_FRAME_HEADER_LEN + frame_length;
            }
        }
char src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &(ip->ip_src), src_ip, INET_ADDRSTRLEN);
        inet_ntop(AF_INET, &(ip->ip_dst), dst_ip, INET_ADDRSTRLEN);
        printf("%s gRPC %s.%d > %s.%d\n", 
            timestamp, 
            src_ip, ntohs(tcp->source), 
            dst_ip, ntohs(tcp->dest));


40 0c 63 6f 6e 74 65 6e 74 2d 74 79 70 65 10 61 70 70 6c 69 63  61 74 69 6f 6e 2f 67 72 70 63